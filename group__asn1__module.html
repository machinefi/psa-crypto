<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSA Crypto: Asn1_module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSA Crypto
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle">
<div class="title">Asn1_module</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiotex__asn1__buf.html">iotex_asn1_buf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiotex__asn1__bitstring.html">iotex_asn1_bitstring</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiotex__asn1__sequence.html">iotex_asn1_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiotex__asn1__named__data.html">iotex_asn1_named_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga5b9a79486f23098246be7c6550ba75ab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#ga5b9a79486f23098246be7c6550ba75ab">IOTEX_OID_SIZE</a>(x)&#160;&#160;&#160;(sizeof(x) - 1)</td></tr>
<tr class="separator:ga5b9a79486f23098246be7c6550ba75ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga118b04b8a25fc30602e82eb7b49ab7d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#ga118b04b8a25fc30602e82eb7b49ab7d2">IOTEX_OID_CMP</a>(oid_str,  oid_buf)</td></tr>
<tr class="separator:ga118b04b8a25fc30602e82eb7b49ab7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c8e4e623ead841f6bf07d1a3037230f"><td class="memItemLeft" align="right" valign="top"><a id="ga6c8e4e623ead841f6bf07d1a3037230f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IOTEX_OID_CMP_RAW</b>(oid_str,  oid_buf,  oid_buf_len)&#160;&#160;&#160;	((<a class="el" href="group__asn1__module.html#ga5b9a79486f23098246be7c6550ba75ab">IOTEX_OID_SIZE</a>(oid_str) != (oid_buf_len)) || memcmp((oid_str), (oid_buf), (oid_buf_len)) != 0)</td></tr>
<tr class="separator:ga6c8e4e623ead841f6bf07d1a3037230f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Functions to parse ASN.1 data structures</h2></td></tr>
<tr class="memitem:ga99cd09520f1d16085d4d981dac36631c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structiotex__asn1__buf.html">iotex_asn1_buf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#ga99cd09520f1d16085d4d981dac36631c">iotex_asn1_buf</a></td></tr>
<tr class="separator:ga99cd09520f1d16085d4d981dac36631c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedad29ff14b60defdc2b79bd90bafea0"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structiotex__asn1__bitstring.html">iotex_asn1_bitstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#gaedad29ff14b60defdc2b79bd90bafea0">iotex_asn1_bitstring</a></td></tr>
<tr class="separator:gaedad29ff14b60defdc2b79bd90bafea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga551fbea4126015a751dc81ba3b519c8b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structiotex__asn1__sequence.html">iotex_asn1_sequence</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#ga551fbea4126015a751dc81ba3b519c8b">iotex_asn1_sequence</a></td></tr>
<tr class="separator:ga551fbea4126015a751dc81ba3b519c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5d59fc033684a38cfcb8bd4a3b8f681"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structiotex__asn1__named__data.html">iotex_asn1_named_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#gab5d59fc033684a38cfcb8bd4a3b8f681">iotex_asn1_named_data</a></td></tr>
<tr class="separator:gab5d59fc033684a38cfcb8bd4a3b8f681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2144250c89d1d270bb8f25e4d743cae8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#ga2144250c89d1d270bb8f25e4d743cae8">iotex_asn1_get_len</a> (unsigned char **p, const unsigned char *end, size_t *len)</td></tr>
<tr class="memdesc:ga2144250c89d1d270bb8f25e4d743cae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of an ASN.1 element. Updates the pointer to immediately behind the length.  <a href="group__asn1__module.html#ga2144250c89d1d270bb8f25e4d743cae8">More...</a><br /></td></tr>
<tr class="separator:ga2144250c89d1d270bb8f25e4d743cae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9a829d33f7956d24ec509ea1d69353d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#gae9a829d33f7956d24ec509ea1d69353d">iotex_asn1_get_tag</a> (unsigned char **p, const unsigned char *end, size_t *len, int tag)</td></tr>
<tr class="memdesc:gae9a829d33f7956d24ec509ea1d69353d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the tag and length of the element. Check for the requested tag. Updates the pointer to immediately behind the tag and length.  <a href="group__asn1__module.html#gae9a829d33f7956d24ec509ea1d69353d">More...</a><br /></td></tr>
<tr class="separator:gae9a829d33f7956d24ec509ea1d69353d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fd11f51e1dcf29ab63c06a7ff6b15b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#ga2fd11f51e1dcf29ab63c06a7ff6b15b9">iotex_asn1_get_bool</a> (unsigned char **p, const unsigned char *end, int *val)</td></tr>
<tr class="memdesc:ga2fd11f51e1dcf29ab63c06a7ff6b15b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a boolean ASN.1 tag and its value. Updates the pointer to immediately behind the full tag.  <a href="group__asn1__module.html#ga2fd11f51e1dcf29ab63c06a7ff6b15b9">More...</a><br /></td></tr>
<tr class="separator:ga2fd11f51e1dcf29ab63c06a7ff6b15b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadffc248368a83691cf9afcde9a9625b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#gadffc248368a83691cf9afcde9a9625b3">iotex_asn1_get_int</a> (unsigned char **p, const unsigned char *end, int *val)</td></tr>
<tr class="memdesc:gadffc248368a83691cf9afcde9a9625b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an integer ASN.1 tag and its value. Updates the pointer to immediately behind the full tag.  <a href="group__asn1__module.html#gadffc248368a83691cf9afcde9a9625b3">More...</a><br /></td></tr>
<tr class="separator:gadffc248368a83691cf9afcde9a9625b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab37e9fb1f04531c3574cd10a3e706fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#gaab37e9fb1f04531c3574cd10a3e706fd">iotex_asn1_get_enum</a> (unsigned char **p, const unsigned char *end, int *val)</td></tr>
<tr class="memdesc:gaab37e9fb1f04531c3574cd10a3e706fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an enumerated ASN.1 tag and its value. Updates the pointer to immediately behind the full tag.  <a href="group__asn1__module.html#gaab37e9fb1f04531c3574cd10a3e706fd">More...</a><br /></td></tr>
<tr class="separator:gaab37e9fb1f04531c3574cd10a3e706fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a1df45b026c29e033aa8400b991dbf6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#ga9a1df45b026c29e033aa8400b991dbf6">iotex_asn1_get_bitstring</a> (unsigned char **p, const unsigned char *end, <a class="el" href="structiotex__asn1__bitstring.html">iotex_asn1_bitstring</a> *bs)</td></tr>
<tr class="memdesc:ga9a1df45b026c29e033aa8400b991dbf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a bitstring ASN.1 tag and its value. Updates the pointer to immediately behind the full tag.  <a href="group__asn1__module.html#ga9a1df45b026c29e033aa8400b991dbf6">More...</a><br /></td></tr>
<tr class="separator:ga9a1df45b026c29e033aa8400b991dbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf3dbc85555925a48ec74693f8481411"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#gaaf3dbc85555925a48ec74693f8481411">iotex_asn1_get_bitstring_null</a> (unsigned char **p, const unsigned char *end, size_t *len)</td></tr>
<tr class="memdesc:gaaf3dbc85555925a48ec74693f8481411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a bitstring ASN.1 tag without unused bits and its value. Updates the pointer to the beginning of the bit/octet string.  <a href="group__asn1__module.html#gaaf3dbc85555925a48ec74693f8481411">More...</a><br /></td></tr>
<tr class="separator:gaaf3dbc85555925a48ec74693f8481411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75f0b28d5ddd26e32fa5ed732552041a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#ga75f0b28d5ddd26e32fa5ed732552041a">iotex_asn1_get_sequence_of</a> (unsigned char **p, const unsigned char *end, <a class="el" href="structiotex__asn1__sequence.html">iotex_asn1_sequence</a> *cur, int tag)</td></tr>
<tr class="memdesc:ga75f0b28d5ddd26e32fa5ed732552041a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses and splits an ASN.1 "SEQUENCE OF &lt;tag&gt;". Updates the pointer to immediately behind the full sequence tag.  <a href="group__asn1__module.html#ga75f0b28d5ddd26e32fa5ed732552041a">More...</a><br /></td></tr>
<tr class="separator:ga75f0b28d5ddd26e32fa5ed732552041a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93a08a2fba5846da29babb1408f2dbdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#ga93a08a2fba5846da29babb1408f2dbdc">iotex_asn1_sequence_free</a> (<a class="el" href="structiotex__asn1__sequence.html">iotex_asn1_sequence</a> *seq)</td></tr>
<tr class="memdesc:ga93a08a2fba5846da29babb1408f2dbdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a heap-allocated linked list presentation of an ASN.1 sequence, including the first element.  <a href="group__asn1__module.html#ga93a08a2fba5846da29babb1408f2dbdc">More...</a><br /></td></tr>
<tr class="separator:ga93a08a2fba5846da29babb1408f2dbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06bd525f0bfe5573972464c62ca05fc7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#ga06bd525f0bfe5573972464c62ca05fc7">iotex_asn1_traverse_sequence_of</a> (unsigned char **p, const unsigned char *end, unsigned char tag_must_mask, unsigned char tag_must_val, unsigned char tag_may_mask, unsigned char tag_may_val, int(*cb)(void *ctx, int tag, unsigned char *start, size_t len), void *ctx)</td></tr>
<tr class="memdesc:ga06bd525f0bfe5573972464c62ca05fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse an ASN.1 SEQUENCE container and call a callback for each entry.  <a href="group__asn1__module.html#ga06bd525f0bfe5573972464c62ca05fc7">More...</a><br /></td></tr>
<tr class="separator:ga06bd525f0bfe5573972464c62ca05fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae91b6efdc0226de390829259e233a0fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#gae91b6efdc0226de390829259e233a0fe">iotex_asn1_get_alg</a> (unsigned char **p, const unsigned char *end, <a class="el" href="structiotex__asn1__buf.html">iotex_asn1_buf</a> *alg, <a class="el" href="structiotex__asn1__buf.html">iotex_asn1_buf</a> *params)</td></tr>
<tr class="memdesc:gae91b6efdc0226de390829259e233a0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an AlgorithmIdentifier ASN.1 sequence. Updates the pointer to immediately behind the full AlgorithmIdentifier.  <a href="group__asn1__module.html#gae91b6efdc0226de390829259e233a0fe">More...</a><br /></td></tr>
<tr class="separator:gae91b6efdc0226de390829259e233a0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5efe576f3e3a8184b773bf88cc237e3b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#ga5efe576f3e3a8184b773bf88cc237e3b">iotex_asn1_get_alg_null</a> (unsigned char **p, const unsigned char *end, <a class="el" href="structiotex__asn1__buf.html">iotex_asn1_buf</a> *alg)</td></tr>
<tr class="memdesc:ga5efe576f3e3a8184b773bf88cc237e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an AlgorithmIdentifier ASN.1 sequence with NULL or no params. Updates the pointer to immediately behind the full AlgorithmIdentifier.  <a href="group__asn1__module.html#ga5efe576f3e3a8184b773bf88cc237e3b">More...</a><br /></td></tr>
<tr class="separator:ga5efe576f3e3a8184b773bf88cc237e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga582bb9ef1c0c33404872294bbda81ee8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structiotex__asn1__named__data.html">iotex_asn1_named_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#ga582bb9ef1c0c33404872294bbda81ee8">iotex_asn1_find_named_data</a> (const <a class="el" href="structiotex__asn1__named__data.html">iotex_asn1_named_data</a> *list, const char *oid, size_t len)</td></tr>
<tr class="memdesc:ga582bb9ef1c0c33404872294bbda81ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a specific named_data entry in a sequence or list based on the OID.  <a href="group__asn1__module.html#ga582bb9ef1c0c33404872294bbda81ee8">More...</a><br /></td></tr>
<tr class="separator:ga582bb9ef1c0c33404872294bbda81ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea384f4f8d0b9dd09ab501dcd572954f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#gaea384f4f8d0b9dd09ab501dcd572954f">iotex_asn1_free_named_data</a> (<a class="el" href="structiotex__asn1__named__data.html">iotex_asn1_named_data</a> *entry)</td></tr>
<tr class="memdesc:gaea384f4f8d0b9dd09ab501dcd572954f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a <a class="el" href="structiotex__asn1__named__data.html">iotex_asn1_named_data</a> entry.  <a href="group__asn1__module.html#gaea384f4f8d0b9dd09ab501dcd572954f">More...</a><br /></td></tr>
<tr class="separator:gaea384f4f8d0b9dd09ab501dcd572954f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e7514f3441df66653a5aa1df468c065"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#ga7e7514f3441df66653a5aa1df468c065">iotex_asn1_free_named_data_list</a> (<a class="el" href="structiotex__asn1__named__data.html">iotex_asn1_named_data</a> **head)</td></tr>
<tr class="memdesc:ga7e7514f3441df66653a5aa1df468c065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all entries in a <a class="el" href="structiotex__asn1__named__data.html">iotex_asn1_named_data</a> list.  <a href="group__asn1__module.html#ga7e7514f3441df66653a5aa1df468c065">More...</a><br /></td></tr>
<tr class="separator:ga7e7514f3441df66653a5aa1df468c065"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">ASN1 Error codes</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp91652e79e1691c582917ccf754f9d814"></a>These error codes are OR'ed to X509 error codes for higher error granularity. ASN1 is a standard to specify data structures. </p>
</td></tr>
<tr class="memitem:ga63591edaf3f00454a5618515445d767f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#ga63591edaf3f00454a5618515445d767f">IOTEX_ERR_ASN1_OUT_OF_DATA</a>&#160;&#160;&#160;-0x0060</td></tr>
<tr class="separator:ga63591edaf3f00454a5618515445d767f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga310b596d9f1b09b6e323c71731ef712f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#ga310b596d9f1b09b6e323c71731ef712f">IOTEX_ERR_ASN1_UNEXPECTED_TAG</a>&#160;&#160;&#160;-0x0062</td></tr>
<tr class="separator:ga310b596d9f1b09b6e323c71731ef712f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8fd6c5aedcfa019663d6904bb2bfc29"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#gac8fd6c5aedcfa019663d6904bb2bfc29">IOTEX_ERR_ASN1_INVALID_LENGTH</a>&#160;&#160;&#160;-0x0064</td></tr>
<tr class="separator:gac8fd6c5aedcfa019663d6904bb2bfc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4de82bb0dcbfc0543b79490a010e9d0b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#ga4de82bb0dcbfc0543b79490a010e9d0b">IOTEX_ERR_ASN1_LENGTH_MISMATCH</a>&#160;&#160;&#160;-0x0066</td></tr>
<tr class="separator:ga4de82bb0dcbfc0543b79490a010e9d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga892741d7a873359cc917c7bf0ac84c8f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#ga892741d7a873359cc917c7bf0ac84c8f">IOTEX_ERR_ASN1_INVALID_DATA</a>&#160;&#160;&#160;-0x0068</td></tr>
<tr class="separator:ga892741d7a873359cc917c7bf0ac84c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d6b060c3fd12e7cbe734be91e2c7647"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#ga8d6b060c3fd12e7cbe734be91e2c7647">IOTEX_ERR_ASN1_ALLOC_FAILED</a>&#160;&#160;&#160;-0x006A</td></tr>
<tr class="separator:ga8d6b060c3fd12e7cbe734be91e2c7647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99b57127246d8d91e479f233cdb4d06e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asn1__module.html#ga99b57127246d8d91e479f233cdb4d06e">IOTEX_ERR_ASN1_BUF_TOO_SMALL</a>&#160;&#160;&#160;-0x006C</td></tr>
<tr class="separator:ga99b57127246d8d91e479f233cdb4d06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">DER constants</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpeab69e4214cba23802e5f50d9da845b8"></a>These constants comply with the DER encoded ASN.1 type tags. DER encoding uses hexadecimal representation. An example DER sequence is:<br  />
</p><ul>
<li>0x02 &ndash; tag indicating INTEGER</li>
<li>0x01 &ndash; length in octets</li>
<li>0x05 &ndash; value Such sequences are typically read into <code>::iotex_x509_buf</code>. </li>
</ul>
</td></tr>
<tr class="memitem:ga73a34f706054cdb0132823b2ecfa66fc"><td class="memItemLeft" align="right" valign="top"><a id="ga73a34f706054cdb0132823b2ecfa66fc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IOTEX_ASN1_BOOLEAN</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:ga73a34f706054cdb0132823b2ecfa66fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga841f3c4e874f142429bb8494c7321f3b"><td class="memItemLeft" align="right" valign="top"><a id="ga841f3c4e874f142429bb8494c7321f3b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IOTEX_ASN1_INTEGER</b>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:ga841f3c4e874f142429bb8494c7321f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7343be30899d48750ae68f54c342aa43"><td class="memItemLeft" align="right" valign="top"><a id="ga7343be30899d48750ae68f54c342aa43"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IOTEX_ASN1_BIT_STRING</b>&#160;&#160;&#160;0x03</td></tr>
<tr class="separator:ga7343be30899d48750ae68f54c342aa43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dd008b289b9b284c52792a3c866ecad"><td class="memItemLeft" align="right" valign="top"><a id="ga7dd008b289b9b284c52792a3c866ecad"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IOTEX_ASN1_OCTET_STRING</b>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:ga7dd008b289b9b284c52792a3c866ecad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a816ace22f43cd9ce4564332200540e"><td class="memItemLeft" align="right" valign="top"><a id="ga5a816ace22f43cd9ce4564332200540e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IOTEX_ASN1_NULL</b>&#160;&#160;&#160;0x05</td></tr>
<tr class="separator:ga5a816ace22f43cd9ce4564332200540e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a798e264d8f2b03a3db3507d97bd29d"><td class="memItemLeft" align="right" valign="top"><a id="ga5a798e264d8f2b03a3db3507d97bd29d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IOTEX_ASN1_OID</b>&#160;&#160;&#160;0x06</td></tr>
<tr class="separator:ga5a798e264d8f2b03a3db3507d97bd29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e03390142e05bfa879d6b51a7c13215"><td class="memItemLeft" align="right" valign="top"><a id="ga4e03390142e05bfa879d6b51a7c13215"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IOTEX_ASN1_ENUMERATED</b>&#160;&#160;&#160;0x0A</td></tr>
<tr class="separator:ga4e03390142e05bfa879d6b51a7c13215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga809d5f1bc5dfec495aff42d6977a5de0"><td class="memItemLeft" align="right" valign="top"><a id="ga809d5f1bc5dfec495aff42d6977a5de0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IOTEX_ASN1_UTF8_STRING</b>&#160;&#160;&#160;0x0C</td></tr>
<tr class="separator:ga809d5f1bc5dfec495aff42d6977a5de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae184780659b10e6c52b1dfe71a78d58a"><td class="memItemLeft" align="right" valign="top"><a id="gae184780659b10e6c52b1dfe71a78d58a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IOTEX_ASN1_SEQUENCE</b>&#160;&#160;&#160;0x10</td></tr>
<tr class="separator:gae184780659b10e6c52b1dfe71a78d58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae59e678c1c919196b5d14a389f9e743"><td class="memItemLeft" align="right" valign="top"><a id="gaae59e678c1c919196b5d14a389f9e743"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IOTEX_ASN1_SET</b>&#160;&#160;&#160;0x11</td></tr>
<tr class="separator:gaae59e678c1c919196b5d14a389f9e743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22a50c24f3feb9b44ef363565c1ba210"><td class="memItemLeft" align="right" valign="top"><a id="ga22a50c24f3feb9b44ef363565c1ba210"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IOTEX_ASN1_PRINTABLE_STRING</b>&#160;&#160;&#160;0x13</td></tr>
<tr class="separator:ga22a50c24f3feb9b44ef363565c1ba210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef90675bbee7a9c629de609bb0cdc721"><td class="memItemLeft" align="right" valign="top"><a id="gaef90675bbee7a9c629de609bb0cdc721"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IOTEX_ASN1_T61_STRING</b>&#160;&#160;&#160;0x14</td></tr>
<tr class="separator:gaef90675bbee7a9c629de609bb0cdc721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4e172542b0ed27a5f435e46e14015fd"><td class="memItemLeft" align="right" valign="top"><a id="gaf4e172542b0ed27a5f435e46e14015fd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IOTEX_ASN1_IA5_STRING</b>&#160;&#160;&#160;0x16</td></tr>
<tr class="separator:gaf4e172542b0ed27a5f435e46e14015fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02019b55bff636a769934f404a32aff9"><td class="memItemLeft" align="right" valign="top"><a id="ga02019b55bff636a769934f404a32aff9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IOTEX_ASN1_UTC_TIME</b>&#160;&#160;&#160;0x17</td></tr>
<tr class="separator:ga02019b55bff636a769934f404a32aff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39935e3ac779eea629104ffbfaac3e2f"><td class="memItemLeft" align="right" valign="top"><a id="ga39935e3ac779eea629104ffbfaac3e2f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IOTEX_ASN1_GENERALIZED_TIME</b>&#160;&#160;&#160;0x18</td></tr>
<tr class="separator:ga39935e3ac779eea629104ffbfaac3e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d83340db16cc64162419c7d5b038715"><td class="memItemLeft" align="right" valign="top"><a id="ga8d83340db16cc64162419c7d5b038715"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IOTEX_ASN1_UNIVERSAL_STRING</b>&#160;&#160;&#160;0x1C</td></tr>
<tr class="separator:ga8d83340db16cc64162419c7d5b038715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae07790f87b9ab497ff8b67f75bb6dd09"><td class="memItemLeft" align="right" valign="top"><a id="gae07790f87b9ab497ff8b67f75bb6dd09"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IOTEX_ASN1_BMP_STRING</b>&#160;&#160;&#160;0x1E</td></tr>
<tr class="separator:gae07790f87b9ab497ff8b67f75bb6dd09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97a3e4e5730116e2eff1a4f99f76ff32"><td class="memItemLeft" align="right" valign="top"><a id="ga97a3e4e5730116e2eff1a4f99f76ff32"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IOTEX_ASN1_PRIMITIVE</b>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:ga97a3e4e5730116e2eff1a4f99f76ff32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b155d30602a9d4f05d194f0ea66737c"><td class="memItemLeft" align="right" valign="top"><a id="ga2b155d30602a9d4f05d194f0ea66737c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IOTEX_ASN1_CONSTRUCTED</b>&#160;&#160;&#160;0x20</td></tr>
<tr class="separator:ga2b155d30602a9d4f05d194f0ea66737c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafab3d1212be468f68d8843f81dbf5744"><td class="memItemLeft" align="right" valign="top"><a id="gafab3d1212be468f68d8843f81dbf5744"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IOTEX_ASN1_CONTEXT_SPECIFIC</b>&#160;&#160;&#160;0x80</td></tr>
<tr class="separator:gafab3d1212be468f68d8843f81dbf5744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9200d7b41887fb65cd67876dd993b540"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>IOTEX_ASN1_IS_STRING_TAG</b>(tag)</td></tr>
<tr class="separator:ga9200d7b41887fb65cd67876dd993b540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6009bdffa440e0e72dececc1298f9cb"><td class="memItemLeft" align="right" valign="top"><a id="gaf6009bdffa440e0e72dececc1298f9cb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IOTEX_ASN1_TAG_CLASS_MASK</b>&#160;&#160;&#160;0xC0</td></tr>
<tr class="separator:gaf6009bdffa440e0e72dececc1298f9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccdf5949b50789e4e486d94193b82f9c"><td class="memItemLeft" align="right" valign="top"><a id="gaccdf5949b50789e4e486d94193b82f9c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IOTEX_ASN1_TAG_PC_MASK</b>&#160;&#160;&#160;0x20</td></tr>
<tr class="separator:gaccdf5949b50789e4e486d94193b82f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcf9004fc73dabdfb724ebcb0cf1c0b4"><td class="memItemLeft" align="right" valign="top"><a id="gabcf9004fc73dabdfb724ebcb0cf1c0b4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IOTEX_ASN1_TAG_VALUE_MASK</b>&#160;&#160;&#160;0x1F</td></tr>
<tr class="separator:gabcf9004fc73dabdfb724ebcb0cf1c0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga9200d7b41887fb65cd67876dd993b540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9200d7b41887fb65cd67876dd993b540">&#9670;&nbsp;</a></span>IOTEX_ASN1_IS_STRING_TAG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOTEX_ASN1_IS_STRING_TAG</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tag</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ((tag) &lt; 32u &amp;&amp; (((1u &lt;&lt; (tag)) &amp;                                                              \</div>
<div class="line">                      ((1u &lt;&lt; IOTEX_ASN1_BMP_STRING) | (1u &lt;&lt; IOTEX_ASN1_UTF8_STRING) |            \</div>
<div class="line">                       (1u &lt;&lt; IOTEX_ASN1_T61_STRING) | (1u &lt;&lt; IOTEX_ASN1_IA5_STRING) |             \</div>
<div class="line">                       (1u &lt;&lt; IOTEX_ASN1_UNIVERSAL_STRING) | (1u &lt;&lt; IOTEX_ASN1_PRINTABLE_STRING) | \</div>
<div class="line">                       (1u &lt;&lt; IOTEX_ASN1_BIT_STRING))) != 0))</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga8d6b060c3fd12e7cbe734be91e2c7647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d6b060c3fd12e7cbe734be91e2c7647">&#9670;&nbsp;</a></span>IOTEX_ERR_ASN1_ALLOC_FAILED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOTEX_ERR_ASN1_ALLOC_FAILED&#160;&#160;&#160;-0x006A</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Memory allocation failed </p>

</div>
</div>
<a id="ga99b57127246d8d91e479f233cdb4d06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99b57127246d8d91e479f233cdb4d06e">&#9670;&nbsp;</a></span>IOTEX_ERR_ASN1_BUF_TOO_SMALL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOTEX_ERR_ASN1_BUF_TOO_SMALL&#160;&#160;&#160;-0x006C</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Buffer too small when writing ASN.1 data structure. </p>

</div>
</div>
<a id="ga892741d7a873359cc917c7bf0ac84c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga892741d7a873359cc917c7bf0ac84c8f">&#9670;&nbsp;</a></span>IOTEX_ERR_ASN1_INVALID_DATA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOTEX_ERR_ASN1_INVALID_DATA&#160;&#160;&#160;-0x0068</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data is invalid. </p>

</div>
</div>
<a id="gac8fd6c5aedcfa019663d6904bb2bfc29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8fd6c5aedcfa019663d6904bb2bfc29">&#9670;&nbsp;</a></span>IOTEX_ERR_ASN1_INVALID_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOTEX_ERR_ASN1_INVALID_LENGTH&#160;&#160;&#160;-0x0064</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Error when trying to determine the length or invalid length. </p>

</div>
</div>
<a id="ga4de82bb0dcbfc0543b79490a010e9d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4de82bb0dcbfc0543b79490a010e9d0b">&#9670;&nbsp;</a></span>IOTEX_ERR_ASN1_LENGTH_MISMATCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOTEX_ERR_ASN1_LENGTH_MISMATCH&#160;&#160;&#160;-0x0066</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Actual length differs from expected length. </p>

</div>
</div>
<a id="ga63591edaf3f00454a5618515445d767f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63591edaf3f00454a5618515445d767f">&#9670;&nbsp;</a></span>IOTEX_ERR_ASN1_OUT_OF_DATA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOTEX_ERR_ASN1_OUT_OF_DATA&#160;&#160;&#160;-0x0060</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Out of data when parsing an ASN1 data structure. </p>

</div>
</div>
<a id="ga310b596d9f1b09b6e323c71731ef712f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga310b596d9f1b09b6e323c71731ef712f">&#9670;&nbsp;</a></span>IOTEX_ERR_ASN1_UNEXPECTED_TAG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOTEX_ERR_ASN1_UNEXPECTED_TAG&#160;&#160;&#160;-0x0062</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ASN1 tag was of an unexpected value. </p>

</div>
</div>
<a id="ga118b04b8a25fc30602e82eb7b49ab7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga118b04b8a25fc30602e82eb7b49ab7d2">&#9670;&nbsp;</a></span>IOTEX_OID_CMP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOTEX_OID_CMP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">oid_str, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">oid_buf&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ((<a class="code" href="group__asn1__module.html#ga5b9a79486f23098246be7c6550ba75ab">IOTEX_OID_SIZE</a>(oid_str) != (oid_buf)-&gt;len) ||                                                \</div>
<div class="line">     memcmp((oid_str), (oid_buf)-&gt;p, (oid_buf)-&gt;len) != 0)</div>
<div class="ttc" id="agroup__asn1__module_html_ga5b9a79486f23098246be7c6550ba75ab"><div class="ttname"><a href="group__asn1__module.html#ga5b9a79486f23098246be7c6550ba75ab">IOTEX_OID_SIZE</a></div><div class="ttdeci">#define IOTEX_OID_SIZE(x)</div><div class="ttdef"><b>Definition:</b> asn1.h:99</div></div>
</div><!-- fragment --><p>Compares an <a class="el" href="structiotex__asn1__buf.html">iotex_asn1_buf</a> structure to a reference OID.</p>
<p>Only works for 'defined' oid_str values (IOTEX_OID_HMAC_SHA1), you cannot use a 'unsigned char *oid' here! </p>

</div>
</div>
<a id="ga5b9a79486f23098246be7c6550ba75ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b9a79486f23098246be7c6550ba75ab">&#9670;&nbsp;</a></span>IOTEX_OID_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOTEX_OID_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(sizeof(x) - 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the size of the binary string, without the trailing \0 </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaedad29ff14b60defdc2b79bd90bafea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedad29ff14b60defdc2b79bd90bafea0">&#9670;&nbsp;</a></span>iotex_asn1_bitstring</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structiotex__asn1__bitstring.html">iotex_asn1_bitstring</a> <a class="el" href="structiotex__asn1__bitstring.html">iotex_asn1_bitstring</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Container for ASN1 bit strings. </p>

</div>
</div>
<a id="ga99cd09520f1d16085d4d981dac36631c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99cd09520f1d16085d4d981dac36631c">&#9670;&nbsp;</a></span>iotex_asn1_buf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structiotex__asn1__buf.html">iotex_asn1_buf</a> <a class="el" href="structiotex__asn1__buf.html">iotex_asn1_buf</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type-length-value structure that allows for ASN1 using DER. </p>

</div>
</div>
<a id="gab5d59fc033684a38cfcb8bd4a3b8f681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5d59fc033684a38cfcb8bd4a3b8f681">&#9670;&nbsp;</a></span>iotex_asn1_named_data</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structiotex__asn1__named__data.html">iotex_asn1_named_data</a> <a class="el" href="structiotex__asn1__named__data.html">iotex_asn1_named_data</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Container for a sequence or list of 'named' ASN.1 data items </p>

</div>
</div>
<a id="ga551fbea4126015a751dc81ba3b519c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga551fbea4126015a751dc81ba3b519c8b">&#9670;&nbsp;</a></span>iotex_asn1_sequence</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structiotex__asn1__sequence.html">iotex_asn1_sequence</a> <a class="el" href="structiotex__asn1__sequence.html">iotex_asn1_sequence</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Container for a sequence of ASN.1 items </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga582bb9ef1c0c33404872294bbda81ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga582bb9ef1c0c33404872294bbda81ee8">&#9670;&nbsp;</a></span>iotex_asn1_find_named_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structiotex__asn1__named__data.html">iotex_asn1_named_data</a>* iotex_asn1_find_named_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structiotex__asn1__named__data.html">iotex_asn1_named_data</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>oid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a specific named_data entry in a sequence or list based on the OID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to seek through </td></tr>
    <tr><td class="paramname">oid</td><td>The OID to look for </td></tr>
    <tr><td class="paramname">len</td><td>Size of the OID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if not found, or a pointer to the existing entry. </dd></dl>

</div>
</div>
<a id="gaea384f4f8d0b9dd09ab501dcd572954f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea384f4f8d0b9dd09ab501dcd572954f">&#9670;&nbsp;</a></span>iotex_asn1_free_named_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iotex_asn1_free_named_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structiotex__asn1__named__data.html">iotex_asn1_named_data</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a <a class="el" href="structiotex__asn1__named__data.html">iotex_asn1_named_data</a> entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The named data entry to free. This function calls iotex_free() on <code>entry-&gt;oid.p</code> and <code>entry-&gt;val.p</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7e7514f3441df66653a5aa1df468c065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e7514f3441df66653a5aa1df468c065">&#9670;&nbsp;</a></span>iotex_asn1_free_named_data_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iotex_asn1_free_named_data_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structiotex__asn1__named__data.html">iotex_asn1_named_data</a> **&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free all entries in a <a class="el" href="structiotex__asn1__named__data.html">iotex_asn1_named_data</a> list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the list of named data entries to free. This function calls <a class="el" href="group__asn1__module.html#gaea384f4f8d0b9dd09ab501dcd572954f" title="Free a iotex_asn1_named_data entry.">iotex_asn1_free_named_data()</a> and iotex_free() on each list element and sets <code>*head</code> to <code>NULL</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae91b6efdc0226de390829259e233a0fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae91b6efdc0226de390829259e233a0fe">&#9670;&nbsp;</a></span>iotex_asn1_get_alg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iotex_asn1_get_alg </td>
          <td>(</td>
          <td class="paramtype">unsigned char **&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structiotex__asn1__buf.html">iotex_asn1_buf</a> *&#160;</td>
          <td class="paramname"><em>alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structiotex__asn1__buf.html">iotex_asn1_buf</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve an AlgorithmIdentifier ASN.1 sequence. Updates the pointer to immediately behind the full AlgorithmIdentifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>On entry, <code>*p</code> points to the start of the ASN.1 element. On successful completion, <code>*p</code> points to the first byte beyond the AlgorithmIdentifier element. On error, the value of <code>*p</code> is undefined. </td></tr>
    <tr><td class="paramname">end</td><td>End of data. </td></tr>
    <tr><td class="paramname">alg</td><td>The buffer to receive the OID. </td></tr>
    <tr><td class="paramname">params</td><td>The buffer to receive the parameters. This is zeroized if there are no parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful or a specific ASN.1 or MPI error code. </dd></dl>

</div>
</div>
<a id="ga5efe576f3e3a8184b773bf88cc237e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5efe576f3e3a8184b773bf88cc237e3b">&#9670;&nbsp;</a></span>iotex_asn1_get_alg_null()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iotex_asn1_get_alg_null </td>
          <td>(</td>
          <td class="paramtype">unsigned char **&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structiotex__asn1__buf.html">iotex_asn1_buf</a> *&#160;</td>
          <td class="paramname"><em>alg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve an AlgorithmIdentifier ASN.1 sequence with NULL or no params. Updates the pointer to immediately behind the full AlgorithmIdentifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>On entry, <code>*p</code> points to the start of the ASN.1 element. On successful completion, <code>*p</code> points to the first byte beyond the AlgorithmIdentifier element. On error, the value of <code>*p</code> is undefined. </td></tr>
    <tr><td class="paramname">end</td><td>End of data. </td></tr>
    <tr><td class="paramname">alg</td><td>The buffer to receive the OID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful or a specific ASN.1 or MPI error code. </dd></dl>

</div>
</div>
<a id="ga9a1df45b026c29e033aa8400b991dbf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a1df45b026c29e033aa8400b991dbf6">&#9670;&nbsp;</a></span>iotex_asn1_get_bitstring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iotex_asn1_get_bitstring </td>
          <td>(</td>
          <td class="paramtype">unsigned char **&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structiotex__asn1__bitstring.html">iotex_asn1_bitstring</a> *&#160;</td>
          <td class="paramname"><em>bs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a bitstring ASN.1 tag and its value. Updates the pointer to immediately behind the full tag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>On entry, <code>*p</code> points to the start of the ASN.1 element. On successful completion, <code>*p</code> is equal to <code>end</code>. On error, the value of <code>*p</code> is undefined. </td></tr>
    <tr><td class="paramname">end</td><td>End of data. </td></tr>
    <tr><td class="paramname">bs</td><td>On success, <a class="el" href="structiotex__asn1__bitstring.html">iotex_asn1_bitstring</a> information about the parsed value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd>
<dd>
<a class="el" href="group__asn1__module.html#ga4de82bb0dcbfc0543b79490a010e9d0b">IOTEX_ERR_ASN1_LENGTH_MISMATCH</a> if the input contains extra data after a valid BIT STRING. </dd>
<dd>
An ASN.1 error code if the input does not start with a valid ASN.1 BIT STRING. </dd></dl>

</div>
</div>
<a id="gaaf3dbc85555925a48ec74693f8481411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf3dbc85555925a48ec74693f8481411">&#9670;&nbsp;</a></span>iotex_asn1_get_bitstring_null()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iotex_asn1_get_bitstring_null </td>
          <td>(</td>
          <td class="paramtype">unsigned char **&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a bitstring ASN.1 tag without unused bits and its value. Updates the pointer to the beginning of the bit/octet string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>On entry, <code>*p</code> points to the start of the ASN.1 element. On successful completion, <code>*p</code> points to the first byte of the content of the BIT STRING. On error, the value of <code>*p</code> is undefined. </td></tr>
    <tr><td class="paramname">end</td><td>End of data. </td></tr>
    <tr><td class="paramname">len</td><td>On success, <code>*len</code> is the length of the content in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd>
<dd>
<a class="el" href="group__asn1__module.html#ga892741d7a873359cc917c7bf0ac84c8f">IOTEX_ERR_ASN1_INVALID_DATA</a> if the input starts with a valid BIT STRING with a nonzero number of unused bits. </dd>
<dd>
An ASN.1 error code if the input does not start with a valid ASN.1 BIT STRING. </dd></dl>

</div>
</div>
<a id="ga2fd11f51e1dcf29ab63c06a7ff6b15b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fd11f51e1dcf29ab63c06a7ff6b15b9">&#9670;&nbsp;</a></span>iotex_asn1_get_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iotex_asn1_get_bool </td>
          <td>(</td>
          <td class="paramtype">unsigned char **&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a boolean ASN.1 tag and its value. Updates the pointer to immediately behind the full tag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>On entry, <code>*p</code> points to the start of the ASN.1 element. On successful completion, <code>*p</code> points to the first byte beyond the ASN.1 element. On error, the value of <code>*p</code> is undefined. </td></tr>
    <tr><td class="paramname">end</td><td>End of data. </td></tr>
    <tr><td class="paramname">val</td><td>On success, the parsed value (<code>0</code> or <code>1</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd>
<dd>
An ASN.1 error code if the input does not start with a valid ASN.1 BOOLEAN. </dd></dl>

</div>
</div>
<a id="gaab37e9fb1f04531c3574cd10a3e706fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab37e9fb1f04531c3574cd10a3e706fd">&#9670;&nbsp;</a></span>iotex_asn1_get_enum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iotex_asn1_get_enum </td>
          <td>(</td>
          <td class="paramtype">unsigned char **&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve an enumerated ASN.1 tag and its value. Updates the pointer to immediately behind the full tag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>On entry, <code>*p</code> points to the start of the ASN.1 element. On successful completion, <code>*p</code> points to the first byte beyond the ASN.1 element. On error, the value of <code>*p</code> is undefined. </td></tr>
    <tr><td class="paramname">end</td><td>End of data. </td></tr>
    <tr><td class="paramname">val</td><td>On success, the parsed value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd>
<dd>
An ASN.1 error code if the input does not start with a valid ASN.1 ENUMERATED. </dd>
<dd>
<a class="el" href="group__asn1__module.html#gac8fd6c5aedcfa019663d6904bb2bfc29">IOTEX_ERR_ASN1_INVALID_LENGTH</a> if the parsed value does not fit in an <code>int</code>. </dd></dl>

</div>
</div>
<a id="gadffc248368a83691cf9afcde9a9625b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadffc248368a83691cf9afcde9a9625b3">&#9670;&nbsp;</a></span>iotex_asn1_get_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iotex_asn1_get_int </td>
          <td>(</td>
          <td class="paramtype">unsigned char **&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve an integer ASN.1 tag and its value. Updates the pointer to immediately behind the full tag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>On entry, <code>*p</code> points to the start of the ASN.1 element. On successful completion, <code>*p</code> points to the first byte beyond the ASN.1 element. On error, the value of <code>*p</code> is undefined. </td></tr>
    <tr><td class="paramname">end</td><td>End of data. </td></tr>
    <tr><td class="paramname">val</td><td>On success, the parsed value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd>
<dd>
An ASN.1 error code if the input does not start with a valid ASN.1 INTEGER. </dd>
<dd>
<a class="el" href="group__asn1__module.html#gac8fd6c5aedcfa019663d6904bb2bfc29">IOTEX_ERR_ASN1_INVALID_LENGTH</a> if the parsed value does not fit in an <code>int</code>. </dd></dl>

</div>
</div>
<a id="ga2144250c89d1d270bb8f25e4d743cae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2144250c89d1d270bb8f25e4d743cae8">&#9670;&nbsp;</a></span>iotex_asn1_get_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iotex_asn1_get_len </td>
          <td>(</td>
          <td class="paramtype">unsigned char **&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the length of an ASN.1 element. Updates the pointer to immediately behind the length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>On entry, <code>*p</code> points to the first byte of the length, i.e. immediately after the tag. On successful completion, <code>*p</code> points to the first byte after the length, i.e. the first byte of the content. On error, the value of <code>*p</code> is undefined. </td></tr>
    <tr><td class="paramname">end</td><td>End of data. </td></tr>
    <tr><td class="paramname">len</td><td>On successful completion, <code>*len</code> contains the length read from the ASN.1 input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd>
<dd>
<a class="el" href="group__asn1__module.html#ga63591edaf3f00454a5618515445d767f">IOTEX_ERR_ASN1_OUT_OF_DATA</a> if the ASN.1 element would end beyond <code>end</code>. </dd>
<dd>
<a class="el" href="group__asn1__module.html#gac8fd6c5aedcfa019663d6904bb2bfc29">IOTEX_ERR_ASN1_INVALID_LENGTH</a> if the length is unparsable. </dd></dl>

</div>
</div>
<a id="ga75f0b28d5ddd26e32fa5ed732552041a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75f0b28d5ddd26e32fa5ed732552041a">&#9670;&nbsp;</a></span>iotex_asn1_get_sequence_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iotex_asn1_get_sequence_of </td>
          <td>(</td>
          <td class="paramtype">unsigned char **&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structiotex__asn1__sequence.html">iotex_asn1_sequence</a> *&#160;</td>
          <td class="paramname"><em>cur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses and splits an ASN.1 "SEQUENCE OF &lt;tag&gt;". Updates the pointer to immediately behind the full sequence tag. </p>
<p>This function allocates memory for the sequence elements. You can free the allocated memory with <a class="el" href="group__asn1__module.html#ga93a08a2fba5846da29babb1408f2dbdc" title="Free a heap-allocated linked list presentation of an ASN.1 sequence, including the first element.">iotex_asn1_sequence_free()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>On error, this function may return a partial list in <code>cur</code>. You must set <code>cur-&gt;next = NULL</code> before calling this function! Otherwise it is impossible to distinguish a previously non-null pointer from a pointer to an object allocated by this function.</dd>
<dd>
If the sequence is empty, this function does not modify <code>*cur</code>. If the sequence is valid and non-empty, this function sets <code>cur-&gt;buf.tag</code> to <code>tag</code>. This allows callers to distinguish between an empty sequence and a one-element sequence.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>On entry, <code>*p</code> points to the start of the ASN.1 element. On successful completion, <code>*p</code> is equal to <code>end</code>. On error, the value of <code>*p</code> is undefined. </td></tr>
    <tr><td class="paramname">end</td><td>End of data. </td></tr>
    <tr><td class="paramname">cur</td><td>A <a class="el" href="structiotex__asn1__sequence.html">iotex_asn1_sequence</a> which this function fills. When this function returns, <code>*cur</code> is the head of a linked list. Each node in this list is allocated with iotex_calloc() apart from <code>cur</code> itself, and should therefore be freed with iotex_free(). The list describes the content of the sequence. The head of the list (i.e. <code>*cur</code> itself) describes the first element, <code>*cur-&gt;next</code> describes the second element, etc. For each element, <code>buf.tag == tag</code>, <code>buf.len</code> is the length of the content of the content of the element, and <code>buf.p</code> points to the first byte of the content (i.e. immediately past the length of the element). Note that list elements may be allocated even on error. </td></tr>
    <tr><td class="paramname">tag</td><td>Each element of the sequence must have this tag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd>
<dd>
<a class="el" href="group__asn1__module.html#ga4de82bb0dcbfc0543b79490a010e9d0b">IOTEX_ERR_ASN1_LENGTH_MISMATCH</a> if the input contains extra data after a valid SEQUENCE OF <code>tag</code>. </dd>
<dd>
<a class="el" href="group__asn1__module.html#ga310b596d9f1b09b6e323c71731ef712f">IOTEX_ERR_ASN1_UNEXPECTED_TAG</a> if the input starts with an ASN.1 SEQUENCE in which an element has a tag that is different from <code>tag</code>. </dd>
<dd>
<a class="el" href="group__asn1__module.html#ga8d6b060c3fd12e7cbe734be91e2c7647">IOTEX_ERR_ASN1_ALLOC_FAILED</a> if a memory allocation failed. </dd>
<dd>
An ASN.1 error code if the input does not start with a valid ASN.1 SEQUENCE. </dd></dl>

</div>
</div>
<a id="gae9a829d33f7956d24ec509ea1d69353d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9a829d33f7956d24ec509ea1d69353d">&#9670;&nbsp;</a></span>iotex_asn1_get_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iotex_asn1_get_tag </td>
          <td>(</td>
          <td class="paramtype">unsigned char **&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the tag and length of the element. Check for the requested tag. Updates the pointer to immediately behind the tag and length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>On entry, <code>*p</code> points to the start of the ASN.1 element. On successful completion, <code>*p</code> points to the first byte after the length, i.e. the first byte of the content. On error, the value of <code>*p</code> is undefined. </td></tr>
    <tr><td class="paramname">end</td><td>End of data. </td></tr>
    <tr><td class="paramname">len</td><td>On successful completion, <code>*len</code> contains the length read from the ASN.1 input. </td></tr>
    <tr><td class="paramname">tag</td><td>The expected tag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd>
<dd>
<a class="el" href="group__asn1__module.html#ga310b596d9f1b09b6e323c71731ef712f">IOTEX_ERR_ASN1_UNEXPECTED_TAG</a> if the data does not start with the requested tag. </dd>
<dd>
<a class="el" href="group__asn1__module.html#ga63591edaf3f00454a5618515445d767f">IOTEX_ERR_ASN1_OUT_OF_DATA</a> if the ASN.1 element would end beyond <code>end</code>. </dd>
<dd>
<a class="el" href="group__asn1__module.html#gac8fd6c5aedcfa019663d6904bb2bfc29">IOTEX_ERR_ASN1_INVALID_LENGTH</a> if the length is unparsable. </dd></dl>

</div>
</div>
<a id="ga93a08a2fba5846da29babb1408f2dbdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93a08a2fba5846da29babb1408f2dbdc">&#9670;&nbsp;</a></span>iotex_asn1_sequence_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iotex_asn1_sequence_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structiotex__asn1__sequence.html">iotex_asn1_sequence</a> *&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a heap-allocated linked list presentation of an ASN.1 sequence, including the first element. </p>
<p>There are two common ways to manage the memory used for the representation of a parsed ASN.1 sequence:</p><ul>
<li>Allocate a head node <code><a class="el" href="structiotex__asn1__sequence.html">iotex_asn1_sequence</a> *head</code> with iotex_calloc(). Pass this node as the <code>cur</code> argument to <a class="el" href="group__asn1__module.html#ga75f0b28d5ddd26e32fa5ed732552041a" title="Parses and splits an ASN.1 &quot;SEQUENCE OF &lt;tag&gt;&quot;. Updates the pointer to immediately behind the full se...">iotex_asn1_get_sequence_of()</a>. When you have finished processing the sequence, call <a class="el" href="group__asn1__module.html#ga93a08a2fba5846da29babb1408f2dbdc" title="Free a heap-allocated linked list presentation of an ASN.1 sequence, including the first element.">iotex_asn1_sequence_free()</a> on <code>head</code>.</li>
<li>Allocate a head node <code><a class="el" href="structiotex__asn1__sequence.html">iotex_asn1_sequence</a> *head</code> in any manner, for example on the stack. Make sure that <code>head-&gt;next == NULL</code>. Pass <code>head</code> as the <code>cur</code> argument to <a class="el" href="group__asn1__module.html#ga75f0b28d5ddd26e32fa5ed732552041a" title="Parses and splits an ASN.1 &quot;SEQUENCE OF &lt;tag&gt;&quot;. Updates the pointer to immediately behind the full se...">iotex_asn1_get_sequence_of()</a>. When you have finished processing the sequence, call <a class="el" href="group__asn1__module.html#ga93a08a2fba5846da29babb1408f2dbdc" title="Free a heap-allocated linked list presentation of an ASN.1 sequence, including the first element.">iotex_asn1_sequence_free()</a> on <code>head-&gt;cur</code>, then free <code>head</code> itself in the appropriate manner.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>The address of the first sequence component. This may be <code>NULL</code>, in which case this functions returns immediately. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga06bd525f0bfe5573972464c62ca05fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06bd525f0bfe5573972464c62ca05fc7">&#9670;&nbsp;</a></span>iotex_asn1_traverse_sequence_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int iotex_asn1_traverse_sequence_of </td>
          <td>(</td>
          <td class="paramtype">unsigned char **&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>tag_must_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>tag_must_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>tag_may_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>tag_may_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *ctx, int tag, unsigned char *start, size_t len)&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse an ASN.1 SEQUENCE container and call a callback for each entry. </p>
<p>This function checks that the input is a SEQUENCE of elements that each have a "must" tag, and calls a callback function on the elements that have a "may" tag.</p>
<p>For example, to validate that the input is a SEQUENCE of <code>tag1</code> and call <code>cb</code> on each element, use </p><div class="fragment"><div class="line"><a class="code" href="group__asn1__module.html#ga06bd525f0bfe5573972464c62ca05fc7">iotex_asn1_traverse_sequence_of</a>(&amp;p, end, 0xff, tag1, 0, 0, cb, ctx);</div>
<div class="ttc" id="agroup__asn1__module_html_ga06bd525f0bfe5573972464c62ca05fc7"><div class="ttname"><a href="group__asn1__module.html#ga06bd525f0bfe5573972464c62ca05fc7">iotex_asn1_traverse_sequence_of</a></div><div class="ttdeci">int iotex_asn1_traverse_sequence_of(unsigned char **p, const unsigned char *end, unsigned char tag_must_mask, unsigned char tag_must_val, unsigned char tag_may_mask, unsigned char tag_may_val, int(*cb)(void *ctx, int tag, unsigned char *start, size_t len), void *ctx)</div><div class="ttdoc">Traverse an ASN.1 SEQUENCE container and call a callback for each entry.</div></div>
</div><!-- fragment --><p>To validate that the input is a SEQUENCE of ANY and call <code>cb</code> on each element, use </p><div class="fragment"><div class="line"><a class="code" href="group__asn1__module.html#ga06bd525f0bfe5573972464c62ca05fc7">iotex_asn1_traverse_sequence_of</a>(&amp;p, end, 0, 0, 0, 0, cb, ctx);</div>
</div><!-- fragment --><p>To validate that the input is a SEQUENCE of CHOICE {NULL, OCTET STRING} and call <code>cb</code> on each element that is an OCTET STRING, use </p><div class="fragment"><div class="line"><a class="code" href="group__asn1__module.html#ga06bd525f0bfe5573972464c62ca05fc7">iotex_asn1_traverse_sequence_of</a>(&amp;p, end, 0xfe, 0x04, 0xff, 0x04, cb, ctx);</div>
</div><!-- fragment --><p>The callback is called on the elements with a "may" tag from left to right. If the input is not a valid SEQUENCE of elements with a "must" tag, the callback is called on the elements up to the leftmost point where the input is invalid.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function is still experimental and may change at any time.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The address of the pointer to the beginning of the ASN.1 SEQUENCE header. This is updated to point to the end of the ASN.1 SEQUENCE container on a successful invocation. </td></tr>
    <tr><td class="paramname">end</td><td>The end of the ASN.1 SEQUENCE container. </td></tr>
    <tr><td class="paramname">tag_must_mask</td><td>A mask to be applied to the ASN.1 tags found within the SEQUENCE before comparing to <code>tag_must_value</code>. </td></tr>
    <tr><td class="paramname">tag_must_val</td><td>The required value of each ASN.1 tag found in the SEQUENCE, after masking with <code>tag_must_mask</code>. Mismatching tags lead to an error. For example, a value of <code>0</code> for both <code>tag_must_mask</code> and <code>tag_must_val</code> means that every tag is allowed, while a value of <code>0xFF</code> for <code>tag_must_mask</code> means that <code>tag_must_val</code> is the only allowed tag. </td></tr>
    <tr><td class="paramname">tag_may_mask</td><td>A mask to be applied to the ASN.1 tags found within the SEQUENCE before comparing to <code>tag_may_value</code>. </td></tr>
    <tr><td class="paramname">tag_may_val</td><td>The desired value of each ASN.1 tag found in the SEQUENCE, after masking with <code>tag_may_mask</code>. Mismatching tags will be silently ignored. For example, a value of <code>0</code> for <code>tag_may_mask</code> and <code>tag_may_val</code> means that any tag will be considered, while a value of <code>0xFF</code> for <code>tag_may_mask</code> means that all tags with value different from <code>tag_may_val</code> will be ignored. </td></tr>
    <tr><td class="paramname">cb</td><td>The callback to trigger for each component in the ASN.1 SEQUENCE that matches <code>tag_may_val</code>. The callback function is called with the following parameters:<ul>
<li><code>ctx</code>.</li>
<li>The tag of the current element.</li>
<li>A pointer to the start of the current element's content inside the input.</li>
<li>The length of the content of the current element. If the callback returns a non-zero value, the function stops immediately, forwarding the callback's return value. </li>
</ul>
</td></tr>
    <tr><td class="paramname">ctx</td><td>The context to be passed to the callback <code>cb</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> if successful the entire ASN.1 SEQUENCE was traversed without parsing or callback errors. </dd>
<dd>
<a class="el" href="group__asn1__module.html#ga4de82bb0dcbfc0543b79490a010e9d0b">IOTEX_ERR_ASN1_LENGTH_MISMATCH</a> if the input contains extra data after a valid SEQUENCE of elements with an accepted tag. </dd>
<dd>
<a class="el" href="group__asn1__module.html#ga310b596d9f1b09b6e323c71731ef712f">IOTEX_ERR_ASN1_UNEXPECTED_TAG</a> if the input starts with an ASN.1 SEQUENCE in which an element has a tag that is not accepted. </dd>
<dd>
An ASN.1 error code if the input does not start with a valid ASN.1 SEQUENCE. </dd>
<dd>
A non-zero error code forwarded from the callback <code>cb</code> in case the latter returns a non-zero value. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
